# 1.字典和集合都是以散列表的形式存储的
* 这里的散列表就是数据结构中我们熟悉的散列表（哈西表）
* 什么可散列的数据类型：
* * 支持hash()函数，且由__hash__()方法得到的散列值始终不变
* * 支持通过__eq__()方法检测可散列对象相等性
* * 若a==b为真则hash(a)==hash(b)为真
* 存储字典中的某一个键值对时，我们将键值对的键作为传入哈西函数（hash(））的参数，哈西函数为自定义的__hash__方法或者内置hash()函数
，由此得到该键值对在哈西表中的散列地址（偏移地址），其值就存储在该散列地址处的内存单元。
* 查找一个键值对时，先将键传入hash()得到散列值，再根据散列值查找，如果找到则对比传入的键和找到的键，若相等，则返回找到的键的位置，若不等，则按哈西冲突的规则继续进行查找，直到查找到一块为空的内存单元，则查找失败。
* 哈西表以存储空间只能占总空间的大约三分之二，达到三分之二之后会自动进行扩容。

由上述可知：
* 为什么要求字典的键不可变类型，因为所有不可变类型都是可散列的（但是元组特殊在其要求元素也是可散列的）
* 字典和集合在查找等一些操作方面，其效率远高於列表，但是其内存使用也高于列表。
* 为什么字典和集合是无序的，因为不管是散列标的扩容，还是新插入的键值对发生哈西冲突，其都可能使哈西表内的元素不在按插入的顺序排列。
* 因为自动扩容的存在，不要在对字典进行迭代（自带内迭代还是按照存储顺序）时修改字典的内容（可能使存储位置变化）

此外：
* 用户自定义的类型都是可散列的，散列值就是他们的id()函数值，所以所有自定义对象的实例在比较时都是不相等的。可以通过实现__eq__来检测对象的相等性，但是要注意可散列对象的三点要求。






    



