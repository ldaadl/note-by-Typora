# +和*
* 它们对序列使用时，都不改变原有的对象而生成一个新的对象

<strong>特别的是，a*n，若a中的元素是可变对象的引用，结果可能不可预料，例如 a = [[]] * 3（用来初始化一额由列表组成的列表）
,得到的结果a = [[], [], []]中，三个[]元素引用的同一个列表。我们一般使用列表推倒来避免上述例子的错误：a = [[] for i in range(3)]
</strong>

# 序列的增量赋值
* *=和+=实际上是__imul__和__iadd__
  
* 以下使用+=分析，*=完全相同
> 如果一个自定义类在没有实现__iadd__，也可以使用+=，不过调用的是__add__ (也就是说元组也和其他不可变类型的变量也可以用+=，但是含义完全不同)。
> 
> a = a + b和a += b完全不同，a = a + b的过程中，生成了一个新的对象，再将此对象赋值给a，
> 而a += b则是类似于a.extend(b),直接在原对象上添加b
> 

例子：
```python
l = [1]
id(l)
l *= 2
id(l)
l = l * 2
id(l)
l.extend(l)
id(l)
t = (1,)
t *= 2
```

# 一个有趣的问题：
我们知道元组是不可变序列：
```python
t = (1,[2])
t[1] += [3]
```
这两句代码的结果将会是抛出TypeError的同时，t变为(1,[2,3])，
为什么会这样？<em>简单来说，当我们进行这样的操作时，Python解释器的操作步骤大概为：1.将t[1]的值存入某个栈的栈顶TOP。2、
进行t[1] += [3]。3、进行t[1] = TOP。</em>异常将在第三步抛出，但是即时第三步不能完成，由于t[1]是可变序列，第二步实际上已经改变了
t[1]的值，t内对t[1]的引用并未改变，所以最终t也改变了。或者将第二部展开为t[1] = t[1].\_\_iadd__([3])(事实上__iadd__没有返回值，但是这个回送结果的过程一定是存在的。)
,这样，问题就很明了了，t[i].\_\_iadd__([3])可以执行，但是赋值完成不了。
如何修改：
> 1.t[1].append(3)
> 
> 2.a = t[1]
>   a += [3]

此外：
> t = (1,[2])
> t[1] = t[1] + [3]
> 引用了新对象，其结果是有异常抛出，且t不改变