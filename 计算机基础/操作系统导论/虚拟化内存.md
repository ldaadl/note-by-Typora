# 虚拟化内存

​		虚拟化CPU时，会有不同进程切换的情况，那我们需要思考，当前没有占据CPU的进程去哪了？早期，他们可能在磁盘里，但是现在基本上都在内存中。也就是说，内存中要同时驻留许多进程，这种情况下，系统出于保护、易用的角度考虑，需要给每个进程提供一个假象，即他们是内存中唯一的进程，他们没有在和其他进程共享物物理内存。

## 一.对地址空间的抽象

​	对于一个进程来说，它在内存中有三个部分：堆、栈、代码区。代码区从地址0开始，堆在代码区的下方向下增长，栈在内存的底部向上增长。而存放这三个部分的内存叫做地址空间，每个进程的地址空间都是独立的、从0开始的，地址空间中的地址是虚拟的，是面向进程自己的，而实际的物理地址只有操作系统和硬件能看见。

## 二.虚拟化内存需要做的事

### 1.机制：地址转换

​	地址空间中的地址是虚拟地址，但是毕竟代码和数据实际上还是存储在物理地址中的，要运行进程，就必须通过某种方式转换虚拟地址得到相应的物理地址，这就涉及到如何将地址空间放入物理内存和如何转化逻辑地址。

#### 动态重定位

需要的硬件：两个硬件寄存器：基址（base）寄存器和界限（bound）寄存器。

思想：进程的地址空间完整的、连续的放入物理内存中。地址空间以0开始，一个基址寄存器保存该进程在物理内存中的实际开始地址，一个界限寄存器确保这个地址在进程地址空间的范围内。它们一起提供了既简单又高效的虚拟内存机制。

操作系统需要做的事：为了实现动态重定位，操作系统必须要处理一些问题。

* 进程创建时，操作系统必须采取行动，为进程的地址空间找到内存空间。由于地址空间是小于物理地址的，做到这一点很容易，操作系统将整个物理地址看作一组槽块，对其标记空闲或者已用即可。
* 进程结束时，操作系统也必须收回它的所有内存，简单来说，就是标记相应的槽块为空闲，然后清除相关的数据结构。
* 进程切换时，由于每个CPU毕竟只有一个基址寄存器和一个界限寄存器（即使有多个也是有限的），但对于每个运行的程序，它们的值都不同，在切换进程时，操作系统必须保存和恢复基础和界限寄存器，它必须将当前基址和界限寄存器中的内容保存在内存中，放在某种每个进程都有的结构中，如进程结构（process structure）或进程控制块（ProcessControl Block，PCB）中。
* 最后，操作系统必须提供异常处理程序，或要一些调用的函数

#### 分段

​	栈和堆之间，有一大块“空闲”空间，如果我们将整个地址空间放入物理内存，那么栈和堆之间的空间并没有被进程使用，却依然占用了实际的物理内存，但设想一个32位（4GB）的地址空间，通常的程序只会使用几兆的内存，但需要整个地址空间都放在内存中。因此，简单的通过基址寄存器和界限寄存器实现的虚拟内存很浪费。另外，如果剩余物理内存无法提供连续区域来放置完整的地址空间，进程便无法运行。这种基址加界限的方式看来并不像我们期望的那样灵活。

​	为了解决这个问题，分段的概念应运而生。引入不止一个基址和界限寄存器对，而是给地址空间内的每个逻辑段（segment）一对，一个段只是地址空间里的一个连续定长的区域，在典型的地址空间里有3个逻辑不同的段：代码、栈和堆。这样，不同的段就可以放于物理内存的不同位置，不需要很大的连续空间，而且堆栈之间的空闲区域也可以不分配物理内存。

#### 分页

​	操作系统对于物理内存的管理有两种方式，一是允许将空间分割成不同的分片，但这个解决方法存在固有的问题。具体来说，将空间切成不同长度的分片以后，空间本身会碎片化（fragmented），随着时间推移，分配内存会变得比较困难。因此，值得考虑第二种方法：将空间分割成固定长度的分片。在虚拟内存中，我们称这种思想为分页，可以追溯到一个早期的重要系统，Atlas[KE+62, L78]。分页不是将一个进程的地址空间分割成几个不同长度的逻辑段（即代码、堆、段），而是分割成固定大小的单元，每个单元称为一页。物理内存中的一页称为一个页帧，在地址空间中叫做虚拟内存页。

​	地址空间内的地址将会被分为两个部分：VPN（虚拟页号）+页内偏移量。每个进程都有一个页表，页表就是一种数据结构，用于将虚拟地址（或者实际上，是虚拟页号）映射到物理地址（物理帧号），操作系统通过虚拟页号（VPN）检索该数组，并在该索引处查找页表项（PTE）。而PTE的内容有PFN（物理帧号）和其他一些有用信息，例如有效位。

​	基址寄存器和限界寄存器在页表结构下仍然有用，他们将负责定位每个进程的页表位置。

#### 分页：快速地址转换（TLB）

​	TLB就和CPU中的高速缓存类似，因为访问页表再访问物理内存是很慢的，TLB可以使这一过程快起来。但TLB也有需要注意的地方：一是再进程切换时如何处理；二是，在TLB已满时，新进入的项该替换掉哪些项。

### 插叙，采用分页机制后如何使页表更小

​	假设一个32位地址空间（232字节），4KB（212字节）的页和一个4字节的页表项。一个地址空间中大约有一百万个虚拟页面（232/212）。乘以页表项的大小，你会发现页表大小为4MB。如果一个进程的页表就这么大，那么所有进程的页表加起来将是一个极大的负担，所以我们必须想办法减小页表。