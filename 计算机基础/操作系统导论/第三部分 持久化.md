# 分布式

## 一.I/O设备和磁盘驱动器

### 1.I/O设备

* 系统架构：

![](C:\Users\Administrator\Desktop\note-by-Typora\计算机基础\操作系统导论\images\12.png)

分层架构的原因：越快的总线越短，因此高性能的内存总线没有足够的空间连接太多设备。

* 标准IO设备的结构：

![](C:\Users\Administrator\Desktop\note-by-Typora\计算机基础\操作系统导论\images\13.png)

​	接口可以让系统软件来控制它的操作

#### 访问和使用IO设备方式

上图中看到，IO设备的接口往往由三个寄存器组成，状态寄存器用于查看当前设备的状态；命令寄存器同志设备执行某个具体的命令；数据寄存器用于存放设备要传输或者接受的数据

* 轮询方式访问：
  * 操作系统反复读取（轮询）状态寄存器状态，待其就绪。
  * 操作系统发送数据到数据寄存器
  * 操作系统将命令写入命令寄存器
  * 操作系统轮询设备，待其完成或失败

* 中断方式：轮询需要很大的CPU开销，利用中断可以减少开销。操作系统向设备发出一个请求后，就使相应进程进入睡眠状态，CPU执行其他任务，当设备完成了自身的任务，他就可以抛出一个设备中断，引发中断服务程序，这时就可继续之前的进程。<u>中断允许了IO和计算重叠，提高了CPU的利用率</u>

#### 补充，中断并不是最好的方案：

这里和多线程有类似的思想，当设备的速度很快时，轮询只需要浪费很短的CPU开销（类似于计算密集型任务），而频繁的中断切换上下文将会带来更大开销。另一个最好不要使用中断的场景是网络。网络端收到大量数据包，如果每一个包都发生一次中断，那么有可能导致操作系统发生活锁（livelock），即不断处理中断而无法处理用户层的请求。另一个基于中断的优化就是合并（coalescing）。设备在抛出中断之前往往会等待一小段时间，在此期间，其他请求可能很快完成，因此多次中断可以合并为一次中断抛出，从而降低处理中断的代价。

#### 补充，利用DMA进行更高效率的数据传送：

CPU可以参与数据的传送，这称之为编程IO，频繁的数据传会加载CPU的负载，而使用DMA可以代替CPU进行数据传输。DMA（Direct Memory Access）引擎是系统中的一个特殊设备，它可以协调完成内存和设备间的数据传递，不需要CPU介入。

#### 操作系统与设备交互的方法

* 内存映射：通过这种方式，硬件将设备寄存器作为内存地址提供。当需要访问设备寄存器时，操作系统装载（读取）或者存入（写入）到该内存地址；然后硬件会将装载/存入转移到设备上，而不是物理内存。

* 明确的IO指令：用明确的I/O指令。这些指令规定了操作系统将数据发送到特定设备寄存器的方法，从而允许构造上文提到的协议。例如in和out指令。

#### 设备驱动程序

​	我们希望操作系统是通用的，例如操作系统中的文件系统，我们希望其可以用于磁盘、固态硬盘、U盘等不同的硬件设备上。

​	在最底层，操作系统的一部分软件清楚地知道设备如何工作，我们将这部分软件称为设备驱动程序（device driver），所有设备交互的细节都封装在其中。高层次的系统调用并不清楚这些驱动程序的细节，他只是将请求或者调用发送给驱动程序，然后驱动程序完成应该完成的工作。

![](C:\Users\Administrator\Desktop\note-by-Typora\计算机基础\操作系统导论\images\14】.png)

​	操作系统中大量的代码都是驱动程序，Linux内核代码超过70%都是驱动程序。当然，任何安装进操作系统的驱动程序，大部分默认都不是激活状态（只有一小部分设备是在系统刚开启时就需要连接）。

### 磁盘驱动器

​	这里只是简单介绍，我们需要知道的是驱动器在操作系统看来是由多个扇区（常常是512B大小）组成的，在具有n个扇区的磁盘上，扇区从0到n−1编号。因此，我们可以将磁盘视为一组扇区，0到n−1是驱动器的地址空间（address space）。

​	多扇区操作是可能的。实际上，许多文件系统一次读取或写入4KB（或更多）。但是，在更新磁盘时，驱动器制造商唯一保证的是单个512字节的写入是原子的（atomic，即它将完整地完成或者根本不会完成）。

## 二.文件系统

### 1.VSFS文件系统的创建

​	我们以VSFS（Very Simple File Sysytem）文件系统的实现过程来展示文件系统有着怎样的结构，又是如何实现的。

​	文件系统是纯软件。与CPU和内存虚拟化的开发不同，我们不会添加硬件功能来使文件系统的某些方面更好地工作。

#### 三种文件

​	再开始构建VSFS之前，先介绍三种常见的文件类型，这三种文件类型很通用，在Linux中也有

* 普通文件：在Linux系统中以-开头，文件就是一个线性字节数组，每个字节都可以读取或写入。每个文件都有某种低级名称（low-levelname），通常是某种数字，常称之为inode号。以一个word文档为例，我们知道除了查看这个文档的内容外，我们还可以查看它的一些其他信息，例如文件大小、文件名称、创建时间等。实际上，在磁盘上保存一个文件的相关信息需要两个地方（所有类型的文件都一样），一个是真正保存文件内容的地方，一个是inode块，用于保存文件的相关信息和指向文件内容的指针，这些数据被称为元数据。

![](C:\Users\Administrator\Desktop\note-by-Typora\计算机基础\操作系统导论\images\15.png)

* 目录文件：目录文件就是windows下的文件夹或者Linux中的目录。它的inode块保存着目录的相关信息，而它的文件内容是一系列的多元组，每一个多元组必须包含的内容是一个位于该目录下的文件名和该文件的inode号，利用inode号可以轻易找到文件的inode块（因此，不同文件的inode号通常是不同的，除了硬链接文件）。

![](C:\Users\Administrator\Desktop\note-by-Typora\计算机基础\操作系统导论\images\16.png)

* 软链接文件：软链接是Linux中所使用的的名称，这个文件的inode和一般文件一样，但是它的文件内容则是另一个文件的路径，这和windows中的快捷方式一致。

  ![](C:\Users\Administrator\Desktop\note-by-Typora\计算机基础\操作系统导论\images\17.png)

​	还有一个与软链接相应的硬链接，但我们不将其归于一种新的文件类型。举个例子，我们对文件/a.txt建立了一个硬链接b.txt，在/目录下就新产生了一个文件b.txt，而其对应的inode号则和a.txt相同，也就是说，a.txt和它的硬链接实际上是一个文件。

​	此外需要注意，硬链接不能链接目录（这可能造成目录树的成环，遍历目录树时将会陷入死循环），不能跨分区（不同分区的inode号可以重复）。

#### 文件系统的数据结构

​	上面介绍三种文件类型时说过，任何文件在磁盘上都由两部分组成，inode块和存放内容的区域。实际上在VSFS中，我们可以将磁盘分为五个区域：超级块、inode位图、数据位图、inode块、数据块。

![](C:\Users\Administrator\Desktop\note-by-Typora\计算机基础\操作系统导论\images\18.png)	上图中每个格子为4KB大小，有1一个超级块，1个inode位图，一个数据位图，5*16个inode块（一个inode块一般256B)，这也意味着该文件分区内最多有80个文件，剩余的是数据块。

##### 超级块

​	超级块包含关于该特定文件系统的信息，包括例如文件系统中有多少个inode和数据块、inode表的开始位置等等。

​	在挂载文件系统时，操作系统将首先读取超级块，初始化各种参数，然后将该卷添加到文件系统树中。当卷中的文件被访问时，系统就会知道在哪里查找所需的磁盘上的结构。

##### 管理空闲空间的方法之一：位示图

​	位示图实际上是一种管理磁盘空闲空间的方法，上面的例子中，有一个inode位示图和一个数据块位示图，这两种位示图中的每一个位都标识着与之对应的一个inode块或者一个数据块是否空闲。

​	管理空闲空间可以有很多方法，位图只是其中一种。还有很多其他方法，例如：

* 空闲列表：超级块中的单个指针保持指向第一个空闲块。在该块内部保留下一个空闲指针，从而通过系统的空闲块形成列表。在需要块时，使用头块并相应地更新列表。

​	当我们创建一个文件时，我们必须为该文件分配一个inode。文件系统将通过位图搜索一个空闲的内容，并将其分配给该文件。文件系统必须将inode标记为已使用（用1），并最终用正确的信息更新磁盘上的位图。

##### inode块

###### inode简介

​	文件系统最重要的磁盘结构之一是inode，几乎所有的文件系统都有类似的结构。每个inode都由一个数字（称为inumber）隐式引用，我们之前称之为文件的低级名称（low-level name）。在前面的例子中，虽然磁盘被文件系统分成了不同区域，但是这些区域的位置都是相对固定的，这是在挂载文件系统格式化硬盘时就决定的（然后将信息记录在超级块里），这就意味着我们是知道inode块的起始地址的，因此，我们将inode块组织成为一个数组，一旦直到inode号，我们就得到了inode块数组的下标索引，就可以轻易找到目标inode块。但是值得注意的一点是，磁盘只能按扇区寻址，通常是512B一个扇区，所以计算得到的inode的地址可能要经过一点取整换算得到inode所在的扇区，读取整个扇区后在内存中才能得到目标inode的内容。

###### inode的内容

​	在每个inode中，实际上是所有关于文件的信息：文件类型（例如，常规文件、目录等）、大小、分配给它的块数、保护信息（如谁拥有该文件以及谁可以访问它）、一些时间信息（包括文件创建、修改或上次访问的时间文件下），以及有关其数据块驻留在磁盘上的位置的信息（如某种类型的指针）。我们将所有关于文件的信息称为元数据（metadata）。实际上，文件系统中除了纯粹的用户数据外，其他任何信息通常都称为元数据。所以目录文件和软链接文件的内容也被视为元数据。

![ext2的inode](C:\Users\Administrator\Desktop\note-by-Typora\计算机基础\操作系统导论\images\19.png)

###### 如何通过inode寻址到文件内容

​	inode中保存着一些指向文件内容地址的指针，这些指针中有直接指针，直接指向一个数据块的地址，也有间接指针，指向一个数据块，但这个数据块内保存着的是文件内容数据块的直接指针。

​	间接指针可以是多级的，来存放更大的文件。直接指针存在的意义是，经研究，大多数文件都是较小的，所以直接指针的存在可以提高读取小文件的速度。

###### 补充寻址文件内容的其他方法

* 使用范围（extent）而不是指针。范围就是一个磁盘指针加一个长度（以块为单位），但是这种方法的局限性是是只能为文件分配连续的控件
* 用链表，这样，在一个inode中，不是有多个指针，只需要一个，指向文件的第一个块。要处理较大的文件，就在该数据块的末尾添加另一个指针等，这样就可以支持大文件。但是这种方法对于随机访问不太友好。
* 对于链表方式的改进，将链表放于内存。

#### 文件系统的访问方法

##### 读取和写入

​	系统启动时，文件系统的超级块将被读取入内存，其他所有内容仍然在内存上。

* 读取文件：不管读取或写入，都需要先打开文件open("/foo/bar",O_RDONLY)，文件系统必须按路径遍历，找到bar。遍历必须要有开始的地方，这个地方最初一定是根目录，根目录的inode是周知的，大多数UNIX系统的inode号是2，在这个例子中，文件系统根据根目录的inode号找到其根目录文件的内容，然后查看foo对应的inode号，以此进行下去，找到bar的inode号，然后将inode块的内容读入内存，进行权限检查，如果用户有读取的权限。在每个进程的打开文件表中，为此进程分配一个<u>文件描述符</u>，并将它返回给用户。

补充：读取不会访问位示图等分配结构

补充，文件描述符：进程在打开一个文件时，需要记录当前文件操作的偏移量等信息。一个文件可以被一个进程多次打开或者被多个进程打开，所以这个偏移量必须由一个进程中的某个变量保存，这个变量就是文件描述符，每次读取或者写入会更新文件描述符

* 写入文件：

### 2.文件系统的API

### 3.VSFS文件系统的改进