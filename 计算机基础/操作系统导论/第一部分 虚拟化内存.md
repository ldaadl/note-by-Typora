# 虚拟化内存

​		虚拟化CPU时，会有不同进程切换的情况，那我们需要思考，当前没有占据CPU的进程去哪了？早期，他们可能在磁盘里，但是现在基本上都在内存中。也就是说，内存中要同时驻留许多进程，这种情况下，系统出于保护、易用的角度考虑，需要给每个进程提供一个假象，即他们是内存中唯一的进程，他们没有在和其他进程共享物物理内存。

## 一.对地址空间的抽象

​	对于一个进程来说，它在内存中有三个部分：堆、栈、代码区。代码区从地址0开始，堆在代码区的下方向下增长，栈在内存的底部向上增长。而存放这三个部分的内存叫做地址空间，每个进程的地址空间都是独立的、从0开始的，地址空间中的地址是虚拟的，是面向进程自己的，而实际的物理地址只有操作系统和硬件能看见。

## 二.虚拟化内存需要做的事

### 1.机制：地址转换

​	地址空间中的地址是虚拟地址，但是毕竟代码和数据实际上还是存储在物理地址中的，要运行进程，就必须通过某种方式转换虚拟地址得到相应的物理地址，这就涉及到如何将地址空间放入物理内存和如何转化逻辑地址。

#### 动态重定位

需要的硬件：两个硬件寄存器：基址（base）寄存器和界限（bound）寄存器。

思想：进程的地址空间完整的、连续的放入物理内存中。地址空间以0开始，一个基址寄存器保存该进程在物理内存中的实际开始地址，一个界限寄存器确保这个地址在进程地址空间的范围内。它们一起提供了既简单又高效的虚拟内存机制。

操作系统需要做的事：为了实现动态重定位，操作系统必须要处理一些问题。

* 进程创建时，操作系统必须采取行动，为进程的地址空间找到内存空间。由于地址空间是小于物理地址的，做到这一点很容易，操作系统将整个物理地址看作一组槽块，对其标记空闲或者已用即可。
* 进程结束时，操作系统也必须收回它的所有内存，简单来说，就是标记相应的槽块为空闲，然后清除相关的数据结构。
* 进程切换时，由于每个CPU毕竟只有一个基址寄存器和一个界限寄存器（即使有多个也是有限的），但对于每个运行的程序，它们的值都不同，在切换进程时，操作系统必须保存和恢复基础和界限寄存器，它必须将当前基址和界限寄存器中的内容保存在内存中，放在某种每个进程都有的结构中，如进程结构（process structure）或进程控制块（ProcessControl Block，PCB）中。
* 最后，操作系统必须提供异常处理程序，或要一些调用的函数

#### 分段

​	栈和堆之间，有一大块“空闲”空间，如果我们将整个地址空间放入物理内存，那么栈和堆之间的空间并没有被进程使用，却依然占用了实际的物理内存，但设想一个32位（4GB）的地址空间，通常的程序只会使用几兆的内存，但需要整个地址空间都放在内存中。因此，简单的通过基址寄存器和界限寄存器实现的虚拟内存很浪费。另外，如果剩余物理内存无法提供连续区域来放置完整的地址空间，进程便无法运行。这种基址加界限的方式看来并不像我们期望的那样灵活。

​	为了解决这个问题，分段的概念应运而生。引入不止一个基址和界限寄存器对，而是给地址空间内的每个逻辑段（segment）一对，一个段只是地址空间里的一个连续定长的区域，在典型的地址空间里有3个逻辑不同的段：代码、栈和堆。这样，不同的段就可以放于物理内存的不同位置，不需要很大的连续空间，而且堆栈之间的空闲区域也可以不分配物理内存。

#### 分页

​	操作系统对于物理内存的管理有两种方式，一是允许将空间分割成不同的分片，但这个解决方法存在固有的问题。具体来说，将空间切成不同长度的分片以后，空间本身会碎片化（fragmented），随着时间推移，分配内存会变得比较困难。因此，值得考虑第二种方法：将空间分割成固定长度的分片。在虚拟内存中，我们称这种思想为分页，可以追溯到一个早期的重要系统，Atlas[KE+62, L78]。分页不是将一个进程的地址空间分割成几个不同长度的逻辑段（即代码、堆、段），而是分割成固定大小的单元，每个单元称为一页。物理内存中的一页称为一个页帧，在地址空间中叫做虚拟内存页。

​	地址空间内的地址将会被分为两个部分：VPN（虚拟页号）+页内偏移量。每个进程都有一个页表，页表就是一种数据结构，用于将虚拟地址（或者实际上，是虚拟页号）映射到物理地址（物理帧号），操作系统通过虚拟页号（VPN）检索该数组，并在该索引处查找页表项（PTE）。而PTE的内容有PFN（物理帧号）和其他一些有用信息，例如有效位。

​	基址寄存器和限界寄存器在页表结构下仍然有用，他们将负责定位每个进程的页表位置。

#### 分页：快速地址转换（TLB）

​	TLB就和CPU中的高速缓存类似，因为访问页表再访问物理内存是很慢的，TLB可以使这一过程快起来。但TLB也有需要注意的地方：一是再进程切换时如何处理；二是，在TLB已满时，新进入的项该替换掉哪些项。

### 插叙，采用分页机制后如何使页表更小

​	假设一个32位地址空间（232字节），4KB（212字节）的页和一个4字节的页表项。一个地址空间中大约有一百万个虚拟页面（232/212）。乘以页表项的大小，你会发现页表大小为4MB。如果一个进程的页表就这么大，那么所有进程的页表加起来将是一个极大的负担，所以我们必须想办法减小页表。

#### 更大的页

思想：页更大，页的数量就减少了，自然页表页减少

缺点：更大的页容易产生内部碎片

#### 分页和分段混合

我们采用分段后，栈和堆之间的空闲区域没有分配实际的物理内存，但是这些区域仍然保存在页表中（被标记为无效），这也是使页表变大的因素之一。

思想：我们的杂合方法不是为进程的整个地址空间提供单个页表，而是为每个逻辑分段提供一个

#### 多级页表

​	<u>多级页表在节省空闲页表空间的同时，还可以打破页表的连续。</u>

### 2.机制：超越物理内存

​	每个进程的地址空间并不算太小，但不管地址空间多大，由于程序的局部性，在较短的时间内我们用到的内存空间都不大。如果操作系统可以把当前没有在用的那部分地址空间找个地方存储起来，那么内存就可以容纳地址空间容量总和比物理内存还要大的许多进程。

​	比物理内存还要大的设备，我们一般想到的是硬盘。我们要做的第一件事情就是，在硬盘上开辟一部分空间用于物理页的移入和移出，这样的空间一般称为交换空间（swap space），linux分区就有一个swap分区。但交换空间不是唯一的硬盘交换目的地，例如，假设运行一个二进制程序。这个二进制程序的代码页最开始是在硬盘上，但程序运行的时候，它们被加载到内存中。但是，如果系统需要在物理内存中腾出空间以满足其他需求，则可以安全地重新使用这些代码页的内存空间，因为稍后它又可以重新从硬盘上的二进制文件加载。

​	在相同的地址空间下，有的页在物理内存，有的页在硬盘，那我们就需要进行区分。做法是，在页表的PTE中增加一位存在位。

### 3.策略：超越物理内存

​	如前文所说，当进程太多时，他们的内存总和超出了物理内存，这个时候，进程的页只有一部分在物理内存中，那么要用到在硬盘上的页的时候必定存在如何将硬盘中的页加载到物理内存（换入）和将物理内存中的页加载到硬盘的问题（换出）。

​	如何加载的页的细节暂不讨论，我们关注的是换出哪些物理内存中的页。

#### 理想情况：最优替换

思想：换出最近不使用的页

问题：最近不使用无法预测。

#### 先进先出：FIFO

#### 随机

#### 接近理想状况，利用历史数据：LRU

思想：换出最不经常使用的页或者最少最近使用的页

问题：不需要预测以后，但记录历史的负担很重

#### 近似LRU

操作系统如何利用使用位来实现近似LRU？可以有很多方法，有一个简单的方法称作时钟算法（clock algorithm）[C69]。想象一下，系统中的所有页都放在一个循环列表中。时钟指针（clock hand）开始时指向某个特定的页（哪个页不重要）。当必须进行页替换时，操作系统检查当前指向的页P的使用位是1还是0。如果是1，则意味着页面P最近被使用（当访问一个页时，操作系统会将使用位置为1），因此不适合被替换。然后，P的使用位设置为0，时钟指针递增到下一页（P + 1）。该算法一直持续到找到一个使用位为0的页，使用位为0意味着这个页最近没有被使用过（在最坏的情况下，所有的页都已经被使用了，那么就将所有页的使用位都设置为0）。请注意，这种方法不是通过使用位来实现近似LRU的唯一方法。实际上，任何周期性地清除使用位，然后通过区分使用位是1和0来判定该替换哪个页的方法都是可以的。Corbato的时钟算法只是一个早期成熟的算法，并且具有不重复扫描内存来寻找未使用页的特点，也就是它在最差情况下，只会遍历一次所有内存。

#### 考虑脏页

时钟算法的一个小修改（最初也由Corbato [C69]提出），是对内存中的页是否被修改的额外考虑。这样做的原因是：如果页已被修改（modified）并因此变脏（dirty），则踢出它就必须将它写回磁盘，这很昂贵。如果它没有被修改（因此是干净的，clean），踢出就没成本。物理帧可以简单地重用于其他目的而无须额外的I/O。因此，一些虚拟机系统更倾向于踢出干净页，而不是脏页。为了支持这种行为，硬件应该包括一个修改位（modifiedbit，又名脏位，dirty bit）。每次写入页时都会设置此位，因此可以将其合并到页面替换算法中。例如，时钟算法可以被改变，以扫描既未使用又干净的页先踢出。无法找到这种页时，再查找脏的未使用页面，等等。

#### 抖动

在结束之前，我们解决了最后一个问题：当内存就是被超额请求时，操作系统应该做什么，这组正在运行的进程的内存需求是否超出了可用物理内存？在这种情况下，系统将不断地进行换页，这种情况有时被称为抖动（thrashing）[D70]。一些早期的操作系统有一组相当复杂的机制，以便在抖动发生时检测并应对。例如，给定一组进程，系统可以决定不运行部分进程，希望减少的进程工作集（它们活跃使用的页面）能放入内存，从而能够取得进展。这种方法通常被称为准入控制（admission control），它表明，少做工作有时比尝试一下子做好所有事情更好，这是我们在现实生活中以及在现代计算机系统中经常遇到的情况（令人遗憾）。目前的一些系统采用更严格的方法处理内存过载。例如，当内存超额请求时，某些版本的Linux会运行“内存不足的杀手程序（out-of-memory killer）”。这个守护进程选择一个内存密集型进程并杀死它，从而以不怎么委婉的方式减少内存。虽然成功地减轻了内存压力，但这种方法可能会遇到问题，例如，如果它杀死X服务器，就会导致所有需要显示的应用程序不可用。