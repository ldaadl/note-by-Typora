# 虚拟化CPU

​	前面说过，操作系统向程序提供一种假象，将单个或多个CPU转换看似为无限数量的CPU，从而让许多程序看似同时运行。

​	如何提供有许多CPU的假象？通过让一个进程只运行一个时间片，然后切换到其他进程，操作系统提供了存在多个虚拟CPU的假象。这就是<u>时分共享</u>（time sharing）CPU技术，允许用户如愿运行多个并发进程。潜在的开销就是性能损失，因为如果CPU必须共享，每个进程的运行就会慢一点。

​	获取CPU的对象是内存中的进程，虚拟化CPU即多个进程分时利用CPU。但这又带来了新的问题，如何确定某一时刻将CPU分配给哪一个进程，是处于公平考虑，亦或是处于效率和用户的交互性角度考虑。

## 一.对进程的抽象

### 1.抽象

​	操作系统为正在运行的程序提供的抽象，就是所谓的进程。进程所包括的内容：地址空间+寄存器。

### 2.创建进程

​	操作系统通过将代码和静态数据加载到内存中，通过创建和初始化栈以及执行与I/O设置相关的其他工作，OS现在（终于）为程序执行搭好了舞台。然后它有最后一项任务：启动程序，在入口处运行，即main()。

### 3.进程的状态

* 运行
* 就绪
* 阻塞

## 二.虚拟化CPU需要做的事情

### 1.底层机制：受限直接执行

​	时分共享CPU时存在两个挑战：

* 如何减少虚拟化CPU带来的开销
* 将CPU交由某个进程后，如何保证进程不会不归还CPU或者利用CPU做一些操作系统所不允许的事情

#### 减少开销

​	这一点我觉得不好理解，因为书上只说了减少开销的做法是让进程直接在CPU上运行，而没有说不减少开销的做法是怎样的。

#### 确保进程不会滥用计算机资源

​	一个进程想做的事有很多，有时候它可能不仅仅只想运行地址空间内的程序和数据，它可能希望通过操作系统调用其他进程或者访问计算机的系统或硬件资源。这个时候，如果操作系统的一些功能仅仅作为一个库被无条件调用，那是不安全的。我们的解决方案是，硬件通过提供不同的执行模式来协助操作系统。在用户模式（user mode）下，应用程序不能完全访问硬件资源。在内核模式（kernel mode）下，操作系统可以访问机器的全部资源。还提供了陷入（trap）内核和从陷阱返回（return-from-trap）到用户模式程序的特别说明，以及一些指令，让操作系统告诉硬件陷阱表（trap table）在内存中的位置。

​	通常情况下，进程是用户模式，许多特权指令无法使用。但进程确实需要使用像I/O之类的特权指令时，它会使用系统调用，系统调用是在Atlas [K+61，L78]等古老机器上开创的，它允许内核小心地向用户程序暴露某些关键功能。要执行系统调用，程序必须执行特殊的陷阱（trap）指令。该指令同时跳入内核并将特权级别提升到内核模式。一旦进入内核，系统就可以执行任何需要的特权操作（如果允许），从而为调用进程执行所需的工作。完成后，操作系统调用一个特殊的从陷阱返回（return-from-trap）指令，如你期望的那样，该指令返回到发起调用的用户程序中，同时将特权级别降低，回到用户模式。

#### 确保进程会归还CPU

​	多个进程的切换依赖于操作系统，确保进程不做非法的事情也依赖于操作系统。但是当一个进程获取CPU时，操作系统就失去了CPU，这也意味着操作系统没有运行，但如果操作系统没有运行，那如何去履行它的职责呢？毫无疑问，用户进程获取CPU时，操作系统无法履行它的职责。所以我们希望的是有硬件或者策略来干预，确保CPU会归还CPU和不进行非法行为。

​	用户进程，需要使用特权指令时，它会陷入操作系统，还有一些有好的进程会定时放弃CPU，但为了防止一些不友好的进程，必须有方法单方面终止当前运行在CPU上的进程。这就是<u>时钟中断</u>，时钟设备可以编程为每隔几毫秒产生一次中断。产生中断时，当前正在运行的进程停止，操作系统中预先配置的中断处理程序（interrupt handler）会运行。此时，操作系统重新获得CPU的控制权，因此可以做它想做的事，例如：停止当前进程，并启动另一个进程。

### 2.进程调度之理论算法

​	前面说了，虚拟化CPU的根本操作就是能够让不同进程能在CPU上切换运行，但前面我们也有问题：如何确定某一时刻将CPU分配给哪一个进程，是处于公平考虑，亦或是处于效率和用户的交互性角度考虑？

#### 先进先出（FIFO）

此处引入一个指标：

<u>周转时间</u>=完成时间-到达时间   对于这个指标，我不想用数据来说明，但是我们可以简单的将其理解为超市收银台排队付款时顾客从开始排队到付完款的时间。

思想：先来的进程获得CPU直到完成任务，后来的排队。

​	这个算法简单，易于实现，但有时候对于周转时间这个指标不太友好。如果三个人排队，第一个人买了巨多东西，结算需要半个小时，而后面两人一个买了一盒口香糖，一个买了一瓶水。这个时候如果按FIFO排队，后面两人的体验就极差，但反过来将第一个人放在最后时，对第一个人来说影响不大，但后两人的体验将会好很多。对于计算机来说也是类似的，多个进程需要使用CPU，有的需要占据CPU很长时间，有的只需要很短时间，这个时候将短时间任务安排在前会使体验比较好。

#### 最短任务优先（SJF）

思想：如标题	

​	但是这里要注意的是，最短任务优先时非抢占式的。举例说某一时刻，进程A到达，他需要100ms完成，当前它是唯一到达的进程，所以它开始运行，但是10ms后B到达了，B只需要1ms即可完成，但由于是非抢占式的，所以不能让A停下来。

#### 最短任务优先（STCF）

思想：和SJF类似，但是是抢占式的

#### 轮转（RR）

引入一个指标：

响应时间=首次运行-到达时间

无论SJF还是STCF，他们都有两个问题，一是对于完成时间长的进程过于不公平，一个完成时间很长的进程可能永远都不会获取CPU；二是响应时间不够好，这对于交互性的进程影响很大。

思想：RR在一个时间片（time slice，有时称为调度量子，scheduling quantum）内运行一个工作，然后切换到运行队列中的下一个任务，而不是运行一个任务直到结束。时间片长度必须是时钟中断周期的倍数。因此，如果时钟中断是每10ms中断一次，则时间片可以是10ms、20ms或10ms的任何其他倍数

​	我们还要考虑的是I/O之类的阻塞操作，如果一个进程获取CPU后进行I/O之类的阻塞操作，也就是说它布莉颖分配给它的CPU，那这个时候进程应该主动将CPU让出来（即使它的时间片没有结束），以提高CPU利用率。

### 3.进程调度之实用算法

​	之前所描述的三个算法都有种种缺陷，特别是SJF和STCF我们很难知道一个进程完成任务的时间，这两个算法也就难以运行。而且，我们还需要区分交互型进程和一般进程。

#### 多级反馈队列（MLFQ）

规则1：如果A的优先级 > B的优先级，运行A（不运行B）。

·规则2：如果A的优先级 = B的优先级，轮转运行A和B。（保证了一定的公平性和交互性）

·规则3：工作进入系统时，放在最高优先级（最上层队列）。

·规则 4：一旦工作用完了其在某一层中的时间配额（无论中间主动放弃了多少次CPU），就降低其优先级（移入低一级队列）。（符合SJF和STCF的思想）

·规则5：经过一段时间S，就将系统中所有工作重新加入最高优先级队列。

#### 实用但不常用的算法：比例份额

思想：将CPU的使用时间按不同的比例份额分给进程

具体实现：略

不常用的原因：难以确定不同进程的比例份额

### 4.多处理器调度

关键：一个进程在某个CPU上运行时，会在该CPU的缓存中维护许多状态。下次该进程在相同CPU上运行时，由于缓存中的数据而执行得更快。相反，在不同的CPU上执行，会由于需要重新加载数据而很慢（好在硬件保证的缓存一致性可以保证正确执行）

#### 单队列调度（SQMS）

思想：将所有需要调度的工作放入一个单独的队列中，依次取得CPU，而取得的CPU可以是任意的。

存在的问题：因此每个工作都不断在不同CPU之间转移，这与缓存亲和的目标背道而驰；系统花费了越来越多的时间在锁的开销上，较少的时间用于系统应该完成的工作

#### 多队列调度（MQMS）

思想：每个CPU都有一个队列，当一个工作进入内存时，它按照某种规则分配进入一个队列

优点：每个CPU调度之间相互独立，就避免了单队列的方式中由于数据共享及同步带来的问题，缓存的亲和性好。

缺点：负载不均，有可能出现这样的情况，一个队列的CPU负担很轻，而另一个CPU的负担很重，这样就会使总体的的CPU利用率降低。